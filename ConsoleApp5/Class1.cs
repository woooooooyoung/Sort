using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp5
{
    internal class Class1
    {
        // 1. 선형정렬 3종 구현 원리 조사
        // 1개의 요소를 재위치시키기 위해 전체를 확인하는 정렬
        // n개의 요소를 재위치시키기 위해 n개를 확인하는 정렬
        // 시간복잡도 : O(N^2)

        // <선택정렬>
        // 데이터 중 가장 작은 값부터 하나씩 선택하여 정렬하는 정렬이 있다
        // 전체를 스캔한 후 주어진 배열 중 최솟값을 찾는다
        // 찾은 최솟값을 맨 앞에 위치한 값과 교체한다
        // 맨 처음 위치를 뺀 나머지 개체를 같은 방법으로 교체한다.
        // 하나의 개체만 남을 때까지 과정을 반복한다.

        // 1. 987[6] -> [6]879   -> [6]8[7]9 -> [6][7]89 -> [6][7][8]9
        // 2. [1]546 -> [1]5[4]6 -> [1][4]56 -> [1][4][5]6
        // 3. 697[5] -> [5]976   -> [5]97[6] -> [5][6]97 -> [5][6]9[7] -> [5][6][7]9
        // 4. [1]65249738 -> [1][2]5649738 -> [1][2][3]649758 ->[1][2][3][4]69758 -> [1][2][3][4][5]9768 -> [1][2][3][4][5][6]798 -> [1][2][3][4][5][6][7]98 -> [1][2][3][4][5][6][7][8]9  

        // <삽입정렬>
        // 삽입정렬은 데이터를 하나씩 꺼내 정렬된 자료 준 적합한 위치에 삽입하여 정렬한다.
        // 삽입정렬은 두 번째 값과 첫 번째 값을 비교하는 것부터 시작한다.
        // 두 번째 값과 첫 번째 값을 비교할 때 두번쨰 값이 첫 번째 값이 작을 경우 첫 번째 값을 뒤로 밀어주고 두 번째 값을 첫번쨰 자리에 넣어둔다
        // 세 번째 두 번째 값을 비교한 후 다르면 교체해주는 방식을 반복한다.
        // 이렇게 교체해주다가 다음 값이 크고 이전 값이 작으면 그대로 둔후에 다음으로 넘어가서 반복해준다. 
        // 
        // 1. 9[8]76 -> [8]976 -> [8]9[7]6 -> [7][8]96 -> [7][8][9]6 -> [7][8][9][6] -> [6][7][8][9] 
        // 2. 9[7]86 -> [7]986 -> [7][9]86 -> [7][9][8]6 -> [7][8][9]6   -> [7][8][9][6] -> [6][7][8][9]
        // 3. 1[5]48 -> 1[4][5]8 -> 1[4][5]8
        // 4. 8[6]5249731 -> [6][8]5249731 -> [5][6][8]249731 -> [2][5][6][8]49731 -> [2][4][5][6][8]9731 -> [2][4][5][6][8][9]731 -> [2][4][5][6][7][8][9]31 -> [2][3][4][5][6][7][8][9]1 -> [1][2][3][4][5][6][7][8][9]

        // <버블정렬>
        // 버블정렬은 서로 인접한 데이터를 비교하여 정렬한다.
        // 서로 인접한 데이터의 크기가 순서대로 되어 있지 않으면 서로 교환한다.
        // 선택정렬과 기본개념이 유사하다.
        // 오름차순을 기준으로 정렬한다
        // 정렬 중 자신보다 큰 개체 만나면그 자리에 멈추고 그 다음개체가 이어나간다
        // 버블정렬은 첫 번째 자료과 두 번째 자료를 비교 교환, 두 번째 자료와 세 번째 자료를 비교 교환 하는 과정을 반복하여 비교하고 교환하면서 정렬한다.
        // 병렬이 끝난 자료는 맨 뒤로 이동하고 다음 정렬에서는 제외되며, 두번쨰 정렬도 끝이나면 그 자료도 정렬에서 제외된다
        // 정렬이 끝날때마다 정렬에서 제외되는 데이터는 하나씩 늘어난다.

        // 1. [9]876     -> 8[9]76   -> 87[9]6 -> 876[9]
        // 2. [8]76[9]   -> 7[8]6[9] -> 76[8][9]
        // 3. [7]6[8][9] -> 6[7][8][9]
        // 4. [8]65249731 -> 6524[8]9731 -> [6]5248731[9] -> 524[6]8731[9] -> [5]246731[8][9] -> 24[5]6731[8][9] -> 245[6]731[8][9] -> 2456[7]31[8][9] -> 245631[7][8][9] -> [2]45631[7][8][9] -> 2[4]5631[7][8][9] -> 24[5]631[7][8][9]
        //                -> 245[6]31[7][8][9] -> 24531[6][7][8][9] -> [2]4531[6][7][8][9] -> 2[4]531[6][7][8][9] -> 24[5]31[6][7][8][9] ->2431[5][6][7][8][9] -> 24[5]31[6][7][8][9] -> 2431[5][6][7][8][9] ->[2]431[5][6][7][8][9]
        //                -> 2[4]31[5][6][7][8][9] -> 231[4][5][6][7][8][9] -> [2]31[4][5][6][7][8][9] -> 2[3]1[4][5][6][7][8][9] -> 21[3][4][5][6][7][8][9] -> [2]1[3][4][5][6][7][8][9] -> 1[2][3][4][5][6][7][8][9]

        // 2. 분할정복정렬 3종 구현 원리 조사
        // 1개의 요소를 재위치시키기 위해 전체의 1/2를 확인하는 정렬 
        // n개의 요소를 재위치시키기 위해 n/2개를 확인하는 정렬
        // 시간복잡도 : O(NlogN)

        // <힙정렬>
        // 힙을 이용하여 우선순위가 가장 높은 요소부터 가져와 정렬
        // 최대 힙 트리나 최소 힙 트리를 구성해 정렬하는 방법이다.
        // 내림차순 정렬을 원하면 최대 힙을 구성하고 오름차순을 원하면 최소 힙을 구성하면 된다

        // <합병정렬>
        // 하나의 리스트를 두개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다름, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.
        // 데이터를 2분할하여 정렬 후 합병
        // 다른 정렬과 다르게 메모리적 부담이 있음
        // 하나의 개체가 남을때까지 나눈 뒤 나눈 값들을 비교해서 작은 값이 왼쪽으로 오게한다
        // 정복
        // 결합

        // {865249731}
        // {{86524}   {9731}}
        // {{{865}  {24}}   {{97}  {31}}}
        // {{{{86}  {5}}  {{2} {4}}}   {{{9}  {7}}  {{3}  {1}}}}
        // {{{{{8} {6}}  {5}}  {{2} {4}}}   {{{9}  {7}}  {{3}  {1}}}}
        // {{{{68}  {5}}  {{2} {4}}}   {{{9}  {7}}  {{3}  {1}}}}
        // {{{568}  {{24}}}   {{{79}}  {{13}}}}
        // {{24568} {1379}}
        // 123456789




        // <퀵정렬>
        // 하나의 피벗을 기준으로 작은값과 큰값을 2분할하여 정렬
        // 메모리적 부담은 적다.
        // 최악의 경우 정렬시간이 오래걸린다. 0의 n^2이 된다
        // 최악의 경우 시간복잡도가 0(n^2)
        // 깨질 수 있는 정렬
        // 퀵정렬이 힙정렬보다 느린 경우가 있다.

        // 3. 분할정복정렬 3종의 원리에 의한 특징 조사(힙정렬, 병렬정렬, 퀵정렬 특징)

        // <힙정렬>
        // 

        // <합병정렬>
        //

        // <퀵정렬>
        //
    }
}
